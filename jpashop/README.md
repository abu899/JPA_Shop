# JPA Shop

## Spring boot with JPA

 - JPA 실습

## OSIV와 성능 최적화

- Open Session In View : Hibernates
- Open EntityManger In View : JPA
- 관례상 OSIV라고 한다

### OSIV ON

 JPA에는 내부적으로 영속성 컨텍스트를 가지지만, 결국 데이터베이스와 연결이 되어야 동작이 되는 것이다.
 그럼 언제 데이터베이스 커넥션을 획득할까?  
 - 보통 트랜잭션이 시작할 때, 데이터베이스의 커넥션을 가져오게 된다. 

그렇다면 이걸 언제 데이터베이스에 돌려줄까, 트랜잭션이 끝나면 커넥션을 돌려줄까?
 - 지연 로딩은 영속성 컨텍스트가 존재해야 가능하고, 영속성 컨텍스트는 기본적으로 데이터베이스 커넥션을 유지해야 가능하다
 - 따라서 트랜잭션이 끝나도 영속성 컨텍스트가 유지되는걸로 봐서 아직 돌려주지 않은 상태라고 짐작할 수 있다.
 - 왜 그랬을까?
   - OSIV ON
     - OSIV가 ON된 상태에는 데이터베이스 커넥션을 API 응답이 끝날 때까지 유지하게 된다
     - 기본적으로 ON이 default로 되어있어서, 그 동안 지연로딩이 가능했던 것이다.
 
<p align="center"><img src="/img/1.png" width="80%"></p>
     
그렇다면 장점만 존재할까?
 - OSIV ON 상태에서는 앞서 말했듯, 커넥션이 API가 종료될 때까지 유지된다
 - 따라서 오랜시간 동안 커넥션 리소스를 사용하기 때문에, 실시간 트래픽이 중요한 어플리케이션에서는 커넥션이 모자랄 수 있다.

### OSIV OFF

<p align="center"><img src="/img/2.png" width="80%"></p>

OSIV를 OFF하게 되면 트랜잭션이 끝날 때, 영속성 컨텍스트를 닫으며 데이터베이스 커넥션을 반환하게 되어 커넥션 리소스를 낭비하지 않게 된다.

- 이 경우 모든 지연로딩을 트랜잭션 안에서 처리해야하는 단점이 존재한다
- 또한 view template에서는 지연로딩이 동작하지 않고 트랜잭션이 끝나기 전에 강제호출이 필요하다
- 해결 방법
  1. 모든 지연로딩을 트랜잭션 안에서 처리
  2. fetch join을 통해 필요한 모든 데이터를 미리 불러오기
  3. 커맨드와 쿼리를 분리하자 (Command_query separation)

고객 서비스의 실시간 API는 OSIV를 끄고 ADMIN처럼 커넥션을 많이 사용하지 않는 곳에서는 OSIV ON을 하자